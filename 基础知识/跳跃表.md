# 跳跃表

## 链表和数组查询和插入的问题

链表的特点是插入非常方便，需要的时间的复杂度很小$O(1)$。但是查找只能使用顺序查找的方式$O(logN)$。

数组的特点是插入不方便，需要大量移动数据，因此时间复杂度为$O(n)$。但是如果是有顺序的查找可以使用二分的方式将复杂度将为$O(logN)$。

在多数据量大的情况下，我们希望查询和插入时间复杂度都为$O(logN)$，这样可以很大的减少数据的计算量。

首先的想到的就是红黑树，或者是B树、AVL树、B+树之类的数据结构，但是这些数据结构实现较为复杂，而且在更改的时候会引起数据结构的拓扑的变化，比如说这些树一定程度上需要旋转，因此也很麻烦。

## 跳跃表的引入

而在现实情况下，为了更好动态调整数据，我们更希望使用链表来存取数据。观察到数组的优势是顺序的查找可以使用二分的方式将复杂度将为$O(logN)$。如何让我们的链表也可以使用二分查找呢，首先因为地址不连续的问题，链表是无法使用随机存储的，因此无法使用类似数组的方式。

我们可以使用另外的方式：将二分查找的时候需要关键对比的节点拿出来，先对比那些节点然后再进行定位。

![](https://img2020.cnblogs.com/blog/1112216/202004/1112216-20200410114448240-1108428407.png)

类似如上，使用第偶数个元素做关键字，单独拿出来，进行单独的查询，查询上面的元素确定位置之后，再在具体的区间里面查找。因此最坏的情况为$N/2+1$。

这样安排还是比较复杂，因此我们将跳跃幅度设定为第`2^i`，每个第`2^i`个节点就有一个链接到这个节点前方下一个第`2^i`节点的链。链的总数仅仅是加倍的，但现在在一次查询中最多只考察哦`logN`个节点，这是因为查找由向前到一个新的节点或者在同一个节点小降到第一级的链组成。

但是这种设置过于呆板，是在所有的key都拿到的时候在进行建立，而且条件严苛不利于进一步拓展。因此对某些条件进行一些放松，我们带有k个链的节点定义为k阶节点（level k node）。任意k阶节点上的第i阶(k>=i)链链接的下一个节点至少由i阶。
我们将把i个链接到前面第`2^i`个节点的链这种限制去掉。

一个节点要不要被索引，建几层的索引，都在节点插入时由随机决定的，当插入新的元素时候，我们为它分配新的节点，这时候，我们必须为他分配阶数，我们还是按之前的比例进行分配，i阶的节点有`1/(2^i)*n`的数量个，因此按这个比例进行分配节点阶数。为了保证均匀，因此我们使用随机化的方式分配。这就是调表（skip list）。

以下使用C++实现为例子，为了简化过程只考虑key没有考虑具体的`<key, value>`对。

### 节点的结构

每一个节点有一个k表示阶数，一个key、一个list表示关键字的索引。具体forward的初始化交给具体的类

```c++
struct Node
{
    int k; // 表示它的阶数
    int key; // key value
    list<Node*> forward;
    Node()=default;
    Node(int _k, int _key): k(_k), key(_key) {};
};
```

### 随机算法

```c++
#include <cstdlib>
using std::rand;
int randLevel()
{
    int level = 1;
    for (;rand() < p && maxLevel; level++);
    return level;
}
```

一般使用$maxLevel=log_{1/p}{N}$

### 查询某个节点

查询操作很简单，类似于二分查找，首先

如果要删除节点，首先要搜索到该节点然后记录相关路径，然后再删除。



参考资料
------------
https://lotabout.me/2018/skip-list/
https://ticki.github.io/blog/skip-lists-done-right/