

## 动态内存与智能指针

静态内存和栈内存，静态内存保存局部static 类static以及定义在任何函数之后的遍历。栈保存非static对象。着两个内存的对象都由编译器创建和销毁。栈对象运行才存在，static对象在使用前分配，程序结束就销毁。

除了这部分还要一个自由空间又叫堆，可以存储动态分配的对象。

两种智能指针：
+ `shared_ptr` 运行多个指针指向同一个对象。
+ `unique_ptr` 独占所指向的对象。
+ `weak_ptr` 伴随类，它是一个弱引用，指向`share_ptr`所管理的对象，着三种类型都定义在`memory`头文件中。
  
智能指针都支持的操作

+ *p 解引用
+ p->mem 等价于 (*p).mem
+ p.get() 返回p中保存的指针，如果智能指针释放了对象，这个就悬空了
+ swap(p, q) 交换p和q => p.swap(q)

`shared_ptr`独有的

+ make_shared<T>(args) 返回一个shared_ptr
+ shared_ptr<T>p(q) p是shared_ptr q的拷贝，此从中会递增q中的计数器。q中的指针必须能转换为`T*`
+ p = q p和q都是shared_ptr，所保存的指针必须能互相转换。此操作会递减p的引用激素，递增q的引用技术；若p的引用计数为，则将其管理的原内存释放
+ p.unique() 如果p.use_count() 为1，则是true
+ p.use_count() 返回共享对象指针数目。

### 使用了动态生存期的资源的类

使用动态内存处于一下三个原因之一：

1. 程序不知道自己需要使用多少对象。（容器）
2. 程序不知道所需对象的准确类型。
3. 程序需要在多个对象间共享数据。

### shared_ptr 和 new 结合使用

接受指针参数的智能指针的构造函数是`explicit`的（有这个的关键字必须显示构造）。
只能使用 shared_ptr<T> p2(new xxx) 不能使用 shared_ptr<T> p2 = new xxxx

默认情况下，一个用来初始化智能指针的普通指针必须指向动态内存，因为智能指针默认使用delete释放它所关联的对象。我们可以将智能指针绑定在一个指向其他类型资源的指针上，但是这样做，必须提供自己的操作来代替delete

