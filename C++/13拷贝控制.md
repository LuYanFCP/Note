## 拷贝赋值与销毁

定义一个类的时候，我们可以显式地或者隐式地指定此类型的对象拷贝、移动、赋值和销毁时做什么。有五种特殊的函数执行这些操作：

+ 拷贝构造函数 (copy constructor)
+ 拷贝赋值运算符 (copy-assignment operator)
+ 移动构造函数 (move constructor)
+ 移动赋值运算符 (move-assignment operator)
+ 析构函数 (destructor)

拷贝和移动构造函数定义了当用同类型的另一个对象初始化本对象在做什么。
拷贝和移动操作定义了将同一个对象赋予同类型的另一个对象的时候在做什么。
析构函数定义了销毁对象的时候在做什么。

### 拷贝构造函数

```c++
class Foo {
public:
    Foo();
    Foo(const Foo&);
}
```

构造拷贝函数在几种情况下基本都是隐式使用的，因此不能为`explicit`

合成拷贝构造函数用来阻止我们拷贝到正在创建的对象。而一般情况。

我们实际上要求编译器使用普通的函数匹配来选择与我们提供参数最匹配的构造函数。当我们使用拷贝构造初始化时，我们要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话还要进行类型转换。

如果一个类有一个移动构造函数时，则拷贝初始化有时使用移动构造函数而非拷贝构造函数来完成。

拷贝构造发生的时机

+ 使用 = 隐式构造`string str2 = "abc"`
+ 将一个对象作为实参传递给一个非引用类型的形参。
+ 从一个返回类型为非引用类型的函数返回一个对象。
+ 用花括号列表初始化一个数组中的元素或者一个集合类中的成员。

#### 参数和返回值

在函数调用过程中，具有非引用类型的参数需要要进行拷贝初始化。类似的，当一个函数具有非引用返回类型时，返回值会被用来初始化调用方法。
拷贝构造函数被用来初始化非引用类类型参数，这一特性解释了为什么构造拷贝函数自己的参数必须是引用类型。如果其参数不是引用类型，则调用递归调用。

#### 拷贝初始化的限制

如果使用的初始化值要求通过一个explicit的构造函数来进行类型转换，那么使用拷贝初始化还是直接初始化就不是无关紧要的。

### 拷贝赋值运算符

与拷贝构造函数一样，如果没有则编译器会自动生成一个。

```c++
class Foo {
public:
    Foo& operator= (const Foo&); // 左侧已经隐含到this种，右侧通过引用传入，为了保持一致，赋值运算符通常返回一个左侧运算对象的引用。
}
```

**另外注意的是：标准库通常要求保存在容器种的类型要具有赋值运算符，而且返回左侧运算对象引用。**

#### 合成拷贝构造运算符

是编译器自动生成的，对于某些类，何查拷贝赋值运算符用来禁止该类型对象的赋值。

### 析构函数

```c++
class Foo {
public:
    ~Foo();  // 析构函数
}
```

析构函数不接受参数，不能被重载。在对象最后一次使用之后，析构函数的函数体可执行类设计者希望执行的任何收尾工作。通常，析构函数释放对象在生存周期分配的所有资源。内置类型没有析构函数，因此销毁内置类型成员什么也不需要做，饮食夕会一个内置指针你类型的成员不会delete它所指的对象。 智能指针在析构阶段会被自动销毁。

调用析构函数的时机

+ 变量离开作用域
+ 当一个对象被销毁时，其成员被销毁。
+ 容器（动态容器或者数组）被销毁时，其元素被销毁
+ 对于动态分配的对象，当对指向它的指针应用delete运算符时被销毁。
+ 对于临时对象，当创建它的表达式结束时被销毁。

#### 合成析构函数

默认为空

### 三五法制

需要析构函数的，一定需要拷贝构造和拷贝赋值。

需要拷贝操作的类也需要赋值操作，反之亦然。

有些类可能只需要拷贝或者赋值操作即可，不需要析构函数，例如：考虑给一个类为每个对象分配一个独有ID，这个类需要一个拷贝构造函数为一个新创建的对象生成一个独一无二的序号。除此之外，这个拷贝构造函数从给定对象拷贝所有其他数据成员。这个类还需要自定义拷贝赋值运算符来避免序号赋值目的对象。但是不需要自定义析构，

### =default

当我们在类内用=default修饰成员的声明时，合成的函数将隐式地声明为内联函数，如果不希望合成的成员是内联函数，应该只对成员的类外定义使用=default，就像对拷贝赋值运算符所做的那样。

### 阻止拷贝

定义删除函数来阻止拷贝，删除函数是这样一种函数：虽然我们声明了它们，但是不能以任何方式使用他们。在函数参数列表加delete来指明

编译器默认将这些合成的成员定义为删除：

+ 如果类的某个成员函数的析构函数是删除的或者是不可访问的(例如，是private 的)则类的合成析构函数被定义为删除的。
+ 如果类的某个成员的拷贝构造函数是删除的或是不可访问的，则类的合成构造函数被定义为删除的。如果类的某个成员的析构函数是删除的或者不可访问的，则类合成的拷贝构造函数也被定为为删除的。
+ 如果类的某个成员的拷贝赋值运算符是删除的或不可访问的，或是类有应该const的引用成员，则类的合成拷贝赋值运算符被定义为删除。
+ 如果类的某个成员的析构函数是删除的或不可访问的，或是类有一个引用成员，它没有类内初始化器，或是类有一个const成员，它没有类内初始化器且类型未显示定义默认构造函数，则该类的默认构造函数被定义为删除的。

如果一个类有数据成员，不能默认构造、拷贝、复制或者销毁，则对应的成员函数将被定义为删除的。

通过private也可以阻止拷贝，用户代码将不能拷贝这个类型的对象。但是，友元和成员函数仍旧可以拷贝对象。为例阻止友元或者拷贝构造函数使用，我们可以声明为private但是不定义它们。
